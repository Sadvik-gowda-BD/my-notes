

Data Structures:

1. Linear Data Structures 
	Elements are stored in sequential order, Middle elements will have one predessor and one successor.
2. Non-Linear Data Structures
		Elements are stored in non-sequential order.
		
3. Static data structure
	Memory allocated at compile time.
	Fast access
	slow insertion and deletion
	
4. Dynamic data structure
	Memory allocate at run time. Maximum size is flexible
	Faster insertion and deletion
	Slower access
	

1. Linear Data Structures - elements are stored in swquential order (Middle elements will have one predessor and one successor)
1)Array:
	 A fixed-size, contiguous block of elements, where each element is accessed by its index.
	 
	 Ex:
		Databases: Storing fixed-length records.
		Game Development: Storing game boards or grid data for chess, snack & ladder (e.g., in a 2D array).
		2-D array in bookMyShow, bus or flight booking
		Mathematical Computations: Representing matrices and vectors.

2)Linked List:
	A collection of nodes, each containing data and a reference to the next node. 
	Types include:
		Singly Linked List
		Doubly Linked List
		Circular Linked List
		
	Ex:
		Music and Video Players: Playlists are often implemented as linked lists, where songs can be added or removed easily.
		Operating Systems: Managing active processes and threads.
		Memory Management: Tracking free memory blocks for allocation.
		
3) Stack:
	A Last-In-First-Out (LIFO) structure; elements are added and removed from the same end.
	
	Ex:
		Browser: History management, where back and forward actions follow a stack.
		Function Call Stack: In programming languages, managing function calls and returns.
		Expression Evaluation: Converting infix expressions to postfix/prefix and vice versa.
		undo & redo option

4)Queue: 
	A First-In-First-Out (FIFO) structure; elements are added at the back and removed from the front.
	Variants: 
	Circular Queue
	Priority Queue - non-linear data structure
	Deque (Double-Ended Queue) - supports add and remove element from both ends
	Blocking Queue - thread safe
	
	Ex:
		Customer Service: Ticketing systems where requests are handled in order of arrival.
		Message application: message need to display in sequence FIFO.
		Networking: Handling packets in routers, where packets are processed in the order received.
		Task Scheduling: Implementing LRU (Least Recently Used) cache where items are added/removed from both ends.

2. Non-Linear Data Structures

5)Tree: A hierarchical structure with nodes connected by edges.
	Binary Tree
	Ex:
		File Systems: Organizing directories and files in a tree structure.
		Organization Structures: Representing reporting hierarchy.
		Compiler Design: Abstract Syntax Tree (AST) for representing the structure of code

	Binary Search Tree (BST)
		Ex:
			Databases: Implementing indexing for efficient search.
			Auto-complete Systems: Storing words in a structured way for quick lookup.
			Priority Queues: In applications requiring dynamically ordered items.
			
	AVL Tree (self-balancing BST)
	Red-Black Tree
		Ex AVL Tree / Red-Black Tree (Self-Balancing Binary Search Trees):
			Databases and File Systems: Efficient storage and retrieval, even with high insertion and deletion frequency.
			Memory Management: Managing free blocks in dynamic memory allocation.
	
	Segment Tree
	B-Tree and B+ Tree (used in databases)

6)Graph: Consists of vertices (nodes) and edges; used to represent networks.
	Ex:
		Social Networks: Representing users and their connections (nodes as users, edges as relationships).
		Maps and Navigation: Cities as nodes, roads as edges, finding shortest paths.
		Recommendation Engines: For example, product recommendations based on user similarity graphs.

3)Hashing Data Structures
	7)Hash Table: Stores key-value pairs for efficient lookup, insertion, and deletion.
	8)Hash Map: An implementation of a hash table with more specific optimizations.
	9)Hash Set
	
	Ex:
		Databases: Implementing caches for faster access to frequently used data.
		Symbol Table in Compilers: Storing identifiers and corresponding values.
		Web Applications: Storing session data by mapping session IDs to data objects

4. Specialized Data Structures
	10)Trie (Prefix Tree): A tree-like data structure used primarily for storing strings and efficient prefix searching.
		Ex:
		Search Engines: Autocomplete and spell-checking.
		Networking: IP routing (trie structures are used to store IP prefixes).
		Word Games: Validating word entries and finding possible word completions.
		It will be always in sorted way
		
		Suffix Trie:
			A suffix trie is constructed to store all possible suffixes of a string. This means that every possible substring of a string can be located by following a path in the trie.
			Suffix tries are useful when you need to search for patterns that may appear at any position in a string, not just at the beginning.
			Suffix tries allow efficient substring searches

	11)Heap: A binary tree-based structure used to implement priority queues.
	12)Min-Heap
	13)Max-Heap
		In heap data will be stored in the Tree hirarchy min/max element will be in root
		Use Case: Priority-based processing.
		Ex:
			Task Scheduling: Managing tasks by priority.
			Implementing Priority Queues: For use cases like emergency rooms or resource allocation.
	14)Disjoint Set (Union-Find): A data structure for tracking elements that belong to disjoint sets, commonly used in graph algorithms.
	15)Bloom Filter: A probabilistic data structure used to test whether an element is a member of a set, with some tolerance for false positives.
		Ex:
		Databases: Quickly determining if an element is not present to reduce unnecessary lookups.



Q)Why B+ trees are used in database index search rather than hash
Hash indexes are not optimized for range queries, where you need to find records within a range of values(that use the =, >, >=, <, <=, or BETWEEN operators). In such cases, a B-tree index would be more appropriate.

-----------------------------------------------------------------------------------------------------------------------------------------------------------




Problem solving technique

1)Prefix Sum
2)Two Pointer
3)Sliding Window
4)Fast & Slow Pointer
5)Linked List In-Place Reversal 
6)Monotonic Stack
7)Top 'k' Elements
8)Quick Select
9)Overlapping Intervals
10)Modified Binary Search 
11)Depth-First Search(DFS) - stack is used
12)Breadth-First Search(BFS) - queue is used
13)Matrix Traversal
14)Backtracking - Exploring all possible solution and back track and try other once the solution not satisfy
15)Dynamic Programming
16)Greedy


Floydâ€™s Cycle Detection Algorithm (Tortoise and Hare).
	his technique is used to detect cycles in a linked list or find duplicate numbers in an array efficiently. It uses two pointers:
	->Slow pointer (Tortoise) moves one step at a time.
	->Fast pointer (Hare) moves two steps at a time.
	If there's a cycle, the two pointers will eventually meet inside the cycle.
	
	Once they meet fast==slow, we can say cycle is exist.
	If we need find start point of cycle then reset slow pointer to 0 and move both slow and fast pointer one one step until meet. The meeting point is the starting point of cycle.
	



==============================
Binary search

It works by repeatedly dividing the search interval in half.
Time complexity of O(log n).

Binary search can be appplied on problems like:
	sorted array
	minimum and maximum range/bound
	Binary Search on the Answer. (try for all min and max possible answers)

Find mid overflow case
   int mid=(low+high)/2 - can lead to overflow if low=50 and high=INTEGER_MAX, low+high value is beyond int range
   Solution
    1)use - long mid
    2)int mid = low+(high-low)/2


âœ… Use while (left <= right) when:
	You're searching for an exact value (like a classic binary search).
	You usually return immediately when you find the element (arr[mid] == target).
	You move left = mid + 1 and right = mid - 1 to shrink the window.
	Ending Condition: left > right
	If you are not sure about the expected answer & ans depend on range, then use ans variable and update ans=mid on possible side.

	
Questions
	1. Search in Rotated Sorted Array
	2. Finding First or Last Occurrence (Bound Problems)
	3. Peak Element (Unimodal Array)
	4. Binary Search on the Answer
		Minimum capacity to ship packages in D days
		Allocate minimum number of pages (book allocation). minPossibleAns= max(pages array) maxPossibleAns= sum(pages array)
		Aggressive cows (maximize minimum distance).
		Koko eating bananas.
	5. Search Space Reduction in Optimization
	
	






======================================
Sliding Window:
	In most of the case for sliding window below pattern is used.
	
	take l and r pointer.
	for(r=0 to N){
	
		while(condition){
			update l pointer;
		}
	
	}
-----------------------------------------------------------------------

Greedy:
A greedy algorithm decides what to do in each step, only based on the current situation, without a thought of how the total problem looks like.

At every step, we can make a choice that looks best at the moment, and we get the optimal solution to the complete problem. 

How it works
	Greedy Choice Property: The problem must be such that making the best choice at each step will lead to the best overall solution.
	Optimal Substructure: The problem must be such that the best solution to the whole problem is made up of the best solutions to each subproblem.

In Greedy I observed that for most of the problem we need to sort the array. Knapsack, job sequence, coin problem etc

->"two and one pass greedy"
-> two pass is traverse array from left to right then right to left
P) Greedy algorith may not work always, it's looks promisssing but not work.
	for Ex in minimum coin for 20 rs problem. Given [18, 10, 1] coins are there according to greedy it pick 18+1+1 3 coins, but 10+10 2 coin is optimized way.
	
---------------------------------------------------------------------

Recursion
public int fact(int n){

	if(n==0){
		return 1;
	}
	
	return n*fact(n-1);

}

Tail recurssion
The recursive call is the last operation in the function.
f=1;
public int fact(int n, int f ){

	if(n==0 ){
		return f;
	}
	
	return fact(n-1, f*n);

}

Tree Recursion
A function calls itself more than once in each invocation.
public int fibonacci(int n) {
    if (n == 0 || n == 1) {
        return n; // Base cases
    }
    return fibonacci(n - 1) + fibonacci(n - 2); // Recursive calls
}


Divide and Conquer
Backtracking: ry possible solutions recursively, and backtrack if a solution doesn't work.
Pick and non-pick


---------------GRAPH-------------------

Topological sort
Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge u-v, vertex u comes before v in the ordering.

Note: Topological Sorting for a graph is not possible if the graph is not a DAG.
	
p) When ever question like something before something the use toplogical sort

P)Dijkstra algorithm
single source shortest path algorithms.
It will work for both directed and non-directed graph. But we've to convert non-directed to directed graph.
It won't work for -ve edges
P)In Dijkstra algorithm can be solve with Queue, PriorityQueue and Set data struct. PQ is used to optimize the time, by using PQ always we pick the minimum distance Pair from the Queue.

P) If the weight is same for all edges then we can normal Queue, PQ is not required.

P)Bellman Ford Algo
single source shortest path algorithms.
we can find shortest path from source to destination for negative edge as well
	- we can find negative cycle as well (if we able still relax node after V-1 time then it has -ve cycle)
	
P)Floyd Warshall
The Floyd Warshall Algorithm is an all pair shortest path algorithm 
We can find shortest path for all pairs
	- we can find -ve cycle (if i==j and ar[i][j] != 0 then negative cycle is there
	

T)MST - Minimum Spanning Tree
M- Minimum -> smallest weight
S- Spanning - connects everything
T- Tree -> no cycle
The tree which has n node and n-1 edges and all nodes are reachable from each other.

Prim's Algorithm
Kruskal's Algorith

Note:
Marking as visited the visit array when added to the queue:
Prevents reprocessing: It ensures you donâ€™t add the same node to the queue multiple times. This avoids duplicate work and reduces unnecessary processing especially in undirected graph.

But in Prims algorith, mark visited when we poll from the queue	

P)DSU - (Disjoint Set Union)
P)you cannot use disjoint set union (DSU) for directed graphs. 
P)In DSU we can group some nodes as component and then we can check they belong to which component by finding the parent
P)In DSU or any graph problem, if we not able use arr[i] as a node (arr[i] could be -ve), use  ValueToIndex Map and then use index as a graph node.
P)To give node value to grid. formula(r, c) = (r * total_Col) + col


-------------Dynamic Programming-------
DP is a method used in algorithm design to solve complex problems by breaking them down into simpler subproblems. It is particularly useful for optimization problems where solutions to subproblems are reused multiple times.

Approach
The top-down approach, also known as memoization & recurssion.
The bottom-up approach, or tabulation, starts with the smallest subproblems and iteratively builds up to the solution.

Key Idea:
"Solve each subproblem once and store the result for future use."
This avoids redundant computation, which is common in naÃ¯ve recursive approaches.

When to Use Dynamic Programming:
	A problem can be solved using DP if it has:

	Overlapping Subproblems:
		The same subproblems are solved multiple times.
		Example: In computing Fibonacci numbers recursively.

	Optimal Substructure:
		The solution to a problem depends on the solutions of its subproblems.
		Example: Shortest path in a graph, knapsack problem.


Ex: Fibonacci problem
In recursion/memoization we start from top/the ans which we need and go until base case, so top-down.
In Tabulation approach we start from 0 base and go upto N, so bottom-up

DP is common for:
	Minimize / Maximize problems (e.g., minimum cost/stone, maximum profit)
	Counting problems (e.g., number of ways to reach a target)
	Try all possible ways problem.
	
ðŸš« Not DP If:
	Subproblems are independent (e.g., merge sort).
	You cannot reuse previous results.
	Each subproblem depends on new inputs every time.
	
Trick to solve:-
	1)Try to represent problem in terms of index.
	2)Do all possible stuffs(direction, jump-1/jump-2,  etc) on that index, according to problem statement.
	3)Put value/answer to that index.If question says:
		->find all ways - add all stuffs
		->find min/max - get min(all stuffs)/ get max(all stuffs)

Points to remember (PTB):
-> Memoization can be used for overlapping sub problems.








---------------------------------------
Must read before Interview.

1)There are problems where we need to find the possible answer range and try for all values to get best output. Then if possible apply Binary Search algorithm.
	For ex: Binary Search on answer
		Book/page allocation problem